{{ define "sqlmgr" }}// auto generated by tuk-gen
{{ $objName := .Name -}}
{{ $structName := printf "s%sSQLMgr" $objName -}}
package {{ .Package }}

import (
    "database/sql"

    "github.com/gocraft/dbr"
    "github.com/tukdesk/base/sql/db"
    "github.com/tukdesk/base/sql/types"
)

var (
    _ sql.Result
    _ db.Conn
    _ types.Id
    _ dbr.Dialect

    ins{{ $objName }}SQLMgr = New{{ $objName }}SQLMgr(nil)
)

func New{{ $objName }}SQLMgr(executor db.Executor) *{{ $structName }} {
    return &{{ $structName }}{
        executor: executor,
    }
}

func {{ $objName }}SQLMgr() *{{ $structName }} {
    return ins{{ $objName }}SQLMgr
}

type {{ $structName }} struct {
    obj *{{ $objName }}
    executor db.Executor
}

func (*{{ $structName }}) Table() string {
    return "{{ .TableIdentifier }}"
}

func (*{{ $structName }}) Engine() string {
    {{ if ne .Engine "" -}}
    return "{{ .Engine }}"
    {{ else -}}
    return db.DefaultEngine()
    {{ end -}}
}

func (this *{{ $structName }}) Conn() (*db.Conn, error) {
    if innerConn != nil {
        return innerConn, nil
    }

    conn, err := db.Get(this.Engine())
    if err != nil {
        return nil, err
    }

    return conn, nil
}

func (this *{{ $structName }}) MustConn() *db.Conn {
    if innerConn != nil {
        return innerConn
    }

    return db.MustGet(this.Engine())
}

func (this *{{ $structName }}) Executor() db.Executor {
    if this.executor != nil {
        return this.executor
    }

    return this.MustConn()
}

func (this *{{ $structName }}) StmtInsertInto(column ...string) *dbr.InsertStmt {
    s := this.Executor().SQL()
    return s.InsertInto(this.Table()).Columns(column...)
}

func (this *{{ $structName }}) StmtSelect(column ...string) *dbr.SelectStmt {
    s := this.Executor().SQL()
    return s.Select(column...).From(this.Table())
}

func (this *{{ $structName }}) StmtUpdate() *dbr.UpdateStmt {
    s := this.Executor().SQL()
    return s.Update(this.Table())
}

func (this *{{ $structName }}) StmtDelete() *dbr.DeleteStmt {
    s := this.Executor().SQL()
    return s.DeleteFrom(this.Table())
}

func (this *{{ $structName }}) Insert(objs ...*{{ $objName }}) (sql.Result, error) {
    if len(objs) == 0 {
        return nil, nil
    }

    exec := this.Executor()

    stmt := this.StmtInsertInto(this.obj.Fields()...)
    for _, obj := range objs {
        stmt = stmt.Values(obj.Values()...)
    }

    return exec.ExecStmt(stmt)
}

func (this *{{ $structName }}) FindOneByPrimaryKey(key {{ .PrimaryKey.Type.GoType }}) (*{{ $objName }}, error) {
    exec := this.Executor()

    return this.FindOne(exec.SQL().Eq("{{ .PrimaryKey.Column }}", key), nil)
}

func (this *{{ $structName }}) FindByPrimaryKeys(keys []{{ .PrimaryKey.Type.GoType }}, orders []db.Order) ([]*{{ $objName }}, error) {
    exec := this.Executor()

    return this.Find(exec.SQL().Eq("{{ .PrimaryKey.Column }}", keys), nil, 0, 0, orders)
}

func (this *{{ $structName }}) FindOne(where dbr.Builder, conds []interface{}) (*{{ $objName }}, error) {
    exec := this.Executor()

    stmt := exec.SQL().Select(this.obj.FieldAll()...).From(this.Table()).Where(where, conds...)

    row := exec.QueryRowStmt(stmt)
    res := &{{ $objName }}{}
    if err := res.ScanAll(row); err != nil {
        return nil, err
    }

    return res, nil
}

func (this *{{ $structName }}) Find(where dbr.Builder, conds []interface{}, offset, limit uint64, orders []db.Order) ([]*{{ $objName }}, error) {
    exec := this.Executor()

    stmt := exec.SQL().Select(this.obj.FieldAll()...).
        From(this.Table()).
        Where(where, conds...)

    if offset > 0 {
        stmt = stmt.Offset(offset)
    }

    if limit > 0 {
        stmt = stmt.Limit(limit)
    }

    for _, order := range orders {
        if order.DESC {
            stmt = stmt.OrderDesc(order.Column)
            continue
        }

        stmt = stmt.OrderAsc(order.Column)
    }

    res := make([]*{{ $objName }}, 0)

    rows, err := exec.QueryStmt(stmt)
    if db.IsErrNoRows(err) {
        return res, nil
    }

    if err != nil {
        return nil, err
    }

    for rows.Next() {
        obj := &{{ $objName }}{}
        if err := obj.ScanAll(rows); err != nil {
            return nil, err
        }

        res = append(res, obj)
    }

    return res, nil
}

func (this *{{ $structName }}) UpdateObject(obj *Account, fields ...string) (int64, error) {
    exec := this.Executor()

    values := map[string]interface{}{}
    for _, field := range fields {
        values[field] = obj.Value(field)
    }

    pk := obj.PrimaryKey()

    return this.Update(exec.SQL().Eq(pk, obj.Value(pk)), nil, values)
}

func (this *{{ $structName }}) Update(where dbr.Builder, conds []interface{}, values map[string]interface{}) (int64, error) {
    if len(values) == 0 {
        return 0, nil
    }

    exec := this.Executor()

    stmt := this.StmtUpdate().SetMap(values)
    if where != nil {
        stmt = stmt.Where(where, conds...)
    }

    res, err := exec.ExecStmt(stmt)
    if err != nil {
        return 0, err
    }

    return res.RowsAffected()
}

func (this *{{ $structName }}) DeleteObject(obj *Account) (int64, error) {
    exec := this.Executor()

    pk := obj.PrimaryKey()

    return this.Delete(exec.SQL().Eq(pk, obj.Value(pk)), nil)
}

func (this *{{ $structName }}) DeleteByPrimaryKeys(keys ...{{ .PrimaryKey.Type.GoType }}) (int64, error) {
    exec := this.Executor()

    pk := this.obj.PrimaryKey()

    return this.Delete(exec.SQL().Eq(pk, keys), nil)
}

func (this *{{ $structName }}) Delete(where dbr.Builder, conds []interface{}) (int64, error) {
    exec := this.Executor()

    stmt := this.StmtDelete().Where(where, conds...)

    res, err := exec.ExecStmt(stmt)
    if err != nil {
        return 0, err
    }

    return res.RowsAffected()
}
{{ end -}}
